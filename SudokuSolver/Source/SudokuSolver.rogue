#===============================================================================
# SudokuSolver.rogue
# October 12, 2020
#===============================================================================
$requireRogue "1.7.7"

uses Utility/ConsoleUI

SudokuSolver()

class SudokuSolver
  METHODS
    method init
      #{
      # Easy
      local board =
        Board(
          [
            [3,0,0,8,0,1,0,0,2],
            [2,0,1,0,3,0,6,0,4],
            [0,0,0,2,0,4,0,0,0],
            [8,0,9,0,0,0,1,0,6],
            [0,6,0,0,0,0,0,5,0],
            [7,0,2,0,0,0,4,0,9],
            [0,0,0,5,0,9,0,0,0],
            [9,0,4,0,8,0,7,0,5],
            [6,0,0,1,0,7,0,0,3]
          ]
        )
      }#

      #{
      # Hard
      local board =
        Board(
          [
            [0,0,6,0,0,0,8,3,2],
            [4,0,0,2,6,0,0,0,0],
            [5,0,0,0,0,1,0,0,0],
            [0,0,0,0,2,4,0,0,0],
            [0,3,1,0,5,0,2,7,0],
            [0,0,0,9,7,0,0,0,0],
            [0,0,0,4,0,0,0,0,9],
            [0,0,0,0,8,6,0,0,3],
            [7,5,4,0,0,0,6,0,0]
          ]
        )
      }#

      # Evil
      local board =
        Board(
          [
            [0,0,0,0,0,6,5,0,7],
            [8,0,0,0,0,0,0,3,9],
            [0,0,0,4,0,0,0,2,0],
            [0,0,7,0,4,0,0,0,0],
            [9,0,0,2,7,3,0,0,4],
            [0,0,0,0,1,0,8,0,0],
            [0,4,0,0,0,1,0,0,0],
            [1,2,0,0,0,0,0,0,3],
            [7,0,6,8,0,0,0,0,0]
          ]
        )

      Console.hide_cursor
      on_exit( ()=>Console.show_cursor; Console.reset )
      Console.clear


      local ui = ConsoleUIView()
      local sudoku_view = SudokuView( board )
      local ui_sudoku_view = ConsoleUITextBox(sudoku_view)
      local ui_move_log = ConsoleUIFrame(MoveLog)
      ui.add( (ui_sudoku_view/UIFiller.v) + UISpacer.h(1) + (UICreditsBox() / ui_move_log) )

      ui.update_layout
      sudoku_view.redraw
      ui.draw

      if (not board.is_solved)
        loop
          System.sleep(0.25)
          if (not board.solve_another_cell) escapeLoop
          sudoku_view.redraw
          ui.update
          ui.draw( &force )
        endLoop
      endIf

      board.highlight = null
      sudoku_view.redraw
      ui.draw( &force )

      Console.set_cursor( 1, Console.height )
      Console.clear_to_eol
endClass

class MoveLog : ConsoleUIList, BufferedPrintWriter<<builder>> [singleton]
  METHODS
    #{
    method count->Int32
      return log.count

    method get( index:Int32 )->String
      return log[ index ]
      }#

    method flush( buffer:StringBuilder )
      local line = buffer->String
      if (line.contains('\n'))
        add( forEach in LineReader(line) )
      else
        add( line )
      endIf
      buffer.clear
endClass

class UICreditsBox : ConsoleUITextBox
  METHODS
    method init
      prior.init( 0, 4 )

    method on_draw
      canvas.clear
      canvas.cursor = XY(0,1)
      print_center( "Sudoku Solver" )
      print_center( "October 18, 2020 by Abe Pralle" )
      canvas.draw( "+-+| |+-+" )
      prior.on_draw

    method print_center( message:String )
      canvas.cursor = XY( (canvas.width - message.count)/2, canvas.cursor.y )
      canvas.println( message )
endClass

class NumberSet( flags=0:Int32 ) [compound]
  METHODS
    method contains( n:Int32 )->Logical
      if (n == 0) return (count < 9)
      local flag = 1 :<<: n
      return (flags & flag)

    method count->Int32
      block flags, n=0
        while (flags)
          if (flags & 1) ++n
          flags = flags :>>: 1
        endWhile
        return n
      endBlock

    method get( i:Int32 )->Int32
      local f = flags
      forEach (n in 1..9)
        f = f :>>: 1
        if (f & 1)
          --i
          if (i < 0) return n
        endIf
      endForEach
      return 0

    method operator+( n:Int32 )->NumberSet
      if (n == 0) return this
      local flag = 1 :<<: n
      require not (flags & flag)
      return NumberSet( flags | flag )

    method operator-( n:Int32 )->NumberSet
      if (n == 0) return this
      local flag = 1 :<<: n
      return NumberSet( flags & !flag )
endClass

class Cell
  PROPERTIES
    board      : Board
    i          : Int32
    j          : Int32
    value      : Int32
    value_candidates = NumberSet( 0b111_111_111_0 )

  METHODS
    method init( board, i, j )
      board.columns[i].cells.add( this )
      board.rows[j].cells.add( this )
      board.square(i,j).cells.add( this )

    method attempt_all_value_candidates( group:CellGroup )->Int32
      forEach (n in value_candidates)
        board.save_state
        value = n

        local next_cell = group.first_empty_cell
        if (next_cell)
          if (next_cell.attempt_all_value_candidates(group))
            board.restore_state
            return n
          endIf
        else
          if (board.solve)
            board.restore_state
            return n
          endIf
        endIf
        board.restore_state
      endForEach
      return 0

    method display
      if (value)
        if (board.highlight is this)
          ConsoleStyle.print( ConsoleStyle.INVERSE )
          print value
          ConsoleStyle.print( ConsoleStyle.INVERSE_OFF )
        else
          print value
        endIf
      else
        print ' '
      endIf

    method set_value( @value )
      if (not value) return
      board.columns[i].eliminate( value )
      board.rows[j].eliminate( value )
      board.square(i,j).eliminate( value )
      value_candidates = NumberSet(0)
      board.highlight = this

    method to->String
      if (value) return "$$ -> $" ("ABCDEFGHI"[i],j+1,value)
      else       return "$$ (0)" ("ABCDEFGHI"[i],j+1)

endClass

class CellGroup
  PROPERTIES
    board      : Board
    cells      = Cell[]

  METHODS
    method init( board )
      board.groups.add( this )

    method count_candidates_matching( value:Int32 )->Int32
      local result = 0
      forEach (cell in cells)
        if (cell.value_candidates.contains(value)) ++result
      endForEach
      return result

    method eliminate( value:Int32 )
      forEach (cell in cells)
        cell.value_candidates -= value
      endForEach

    method empty_count->Int32
      local result = 0
      if ((forEach in cells).value == 0) ++result
      return result

    method first_empty_cell->Cell
      forEach (cell in cells)
        if (cell.value == 0) return cell
      endForEach
      return null

    method is_valid->Logical
      local set = NumberSet()
      forEach (cell in cells)
        if (cell.value)
          if (set.contains(cell.value)) return false
          set += cell.value
        elseIf (cell.value_candidates.count == 0)
          # No value and no value candidates
          return false
        endIf
      endForEach
      return true
endClass

class Row : CellGroup
  PROPERTIES
    i : Int32

  METHODS
    method init( board, i )
      prior.init( board )
endClass

class Column : CellGroup
  PROPERTIES
    j : Int32

  METHODS
    method init( board, j )
      prior.init( board )
endClass

class Square : CellGroup
  PROPERTIES
    i : Int32
    j : Int32

  METHODS
    method init( board, i, j )
      prior.init( board )
endClass

class Board
  PROPERTIES
    cells   = Cell[]
    rows    = Row[]
    columns = Column[]
    squares = Square[]
    groups  = CellGroup[]

    highlight : Cell

    saved_state = Byte[]

    solution    : Int32[]
    # A solve'd board will fill in this solution so that we don't repeat a depth-first
    # search more than once.

  METHODS
    method init
      columns.add( Column(this,forEach in 0..8) )
      rows.add( Row(this,forEach in 0..8) )

      forEach (j in 0..2)
        forEach (i in 0..2)
          squares.add( Square(this,i,j) )
        endForEach
      endForEach

      forEach (j in 0..8)
        forEach (i in 0..8)
          cells.add( Cell(this,i,j) )
        endForEach
      endForEach

    method init( numbers:Int32[][] )
      this.init
      forEach (j in 0..8)
        forEach (i in 0..8)
          cell(i,j).value = numbers[j][i]
        endForEach
      endForEach
      highlight = null

    method cell( i:Int32, j:Int32 )->Cell
      if (i < 0 or i > 8 or j < 0 or j > 8) return null
      return cells[ j*9 + i ]

    method depth_first_search->Logical
      if (solution)
        # Just pick a cell from the previously discovered solution that we don't have yet
        forEach (cell at i in cells)
          if (cell.value == 0)
            cell.value = solution[i]
            return true
          endIf
        endForEach
      endIf

      groups.sort( (a,b) => a.empty_count < b.empty_count )
      forEach (group in groups)
        local cell = group.first_empty_cell
        if (cell)
          local success_value = cell.attempt_all_value_candidates( group )
          if (success_value)
            cell.value = success_value
            return true
          endIf
        endIf
      endForEach
      return false

      #{
      local cells = cells.cloned
      cells.keep( (cell) => (cell.value==0) )
      cells.sort( (a,b) => a.value_candidates.count <= b.value_candidates.count )
      forEach (cell at index in cells)
        if (not cell.value)
          forEach (value in cell.value_candidates)
            save_state
            cell.value = value
            if (solve)
              restore_state
              cell.value = value
              return true
            endIf
            if (is_solved) throw Error("WTF")
            restore_state
          endForEach
        endIf
      endForEach
      return false
      }#

    method display
      forEach (j in 0..8)
        if (j == 3 or j == 6) println "---+---+---"
        forEach (i in 0..8)
          if (i == 3 or i == 6) print '|'
          cell(i,j).display
        endForEach
        println
      endForEach
      println

    method find_cell_with_single_value_candidate->Logical
      forEach (cell in cells)
        if (cell.value_candidates.count == 1)
          cell.value = cell.value_candidates[0]
          return true
        endIf
      endForEach

      return false

    method find_cell_with_unique_value_candidate->Logical
      if (find_cell_with_unique_value_candidate(forEach in groups)) return true
      return false

    method find_cell_with_unique_value_candidate( group:CellGroup )->Logical
      forEach (n in 1..9)
        if (group.count_candidates_matching(n) == 1)
          forEach (cell in group.cells)
            if (cell.value_candidates.contains(n))
              cell.value = n
              return true
            endIf
          endForEach
        endIf
      endForEach

      return false

    method is_solved->Logical
      if ((forEach in cells).value == 0) return false
      return true

    method is_valid->Logical
      if (not (forEach in groups).is_valid) return false
      return true

    method restore_state
      (forEach in cells).value_candidates = NumberSet( 0b111_111_111_0 )
      forEach (cell at i in cells step -1)
        cell.value = saved_state.remove_last
      endForEach
      highlight = null

    method save_state
      saved_state.reserve( 81 )
      saved_state.add( (forEach in cells).value )

    method solve->Logical
      loop
        if (not is_valid) return false
        if (is_solved)
          solution = Int32[](81)
          forEach (cell in cells) solution.add( cell.value )
          return true
        endIf
        if (find_cell_with_single_value_candidate) nextIteration
        if (depth_first_search) nextIteration
        return false
      endLoop

    method solve_another_cell->Logical
      if (find_cell_with_single_value_candidate)
        MoveLog.println( "$ (cell with only one candidate value)"(highlight) )
        return true
      endIf
      if (find_cell_with_unique_value_candidate)
        MoveLog.println( "$ (cell with unique candidate value within group)"(highlight) )
        return true
      endIf
      if (depth_first_search)
        MoveLog.println( "$ (depth-first search)"(highlight) )
        return true
      endIf
      return false

    method square( i:Int32, j:Int32 )->Square
      i /= 3
      j /= 3
      if (i < 0 or i > 2 or j < 0 or j > 2) return null
      return squares[ j*3 + i ]

    method unfilled_count->Int32
      local count = 0
      if ((forEach in cells).value == 0) ++count
      return count
endClass


class SudokuView : TextCanvas
  PROPERTIES
    board          : Board

  METHODS
    method init( board )
      prior.init( 37, 37, 0 )

      style.[clear,dim]
      draw( Box(0,0,37,37), "+-+| |+-+" )
      forEach (j in 0..8)
        forEach (i in 0..8)
          draw( Box(i*4,j*4,5,5), "+-+| |+-+" )
        endForEach
      endForEach
      style.clear

      draw( Box(3*4,0,1,37), "|" )
      draw( Box(6*4,0,1,37), "|" )
      draw( Box(0,3*4,37,1), "-" )
      draw( Box(0,6*4,37,1), "-" )
      draw( Box(3*4,3*4,13,13), "+-+| |+-+" )

    method redraw
      forEach (j in 0..8)
        forEach (i in 0..8)
          local cell = board.cell(i,j)
          local x = i*4 + 1
          local y = j*4 + 1
          if (cell.value)
            if (cell is board.highlight) style.inverse
            fill( Box(x,y,3,3), ' ' )
            set( x+1, y+1, Character('0'+cell.value) )
            style.inverse_off
          else
            style.dim
            Console.flush
            forEach (jj in 0..2)
              forEach (ii in 0..2)
                local n = jj*3 + ii + 1
                if (cell.value_candidates.contains(n))
                  set( x+ii, y+jj, Character('0'+n) )
                else
                  set( x+ii, y+jj, ' ' )
                endIf
              endForEach
            endForEach
            style.dim_off
          endIf
        endForEach
      endForEach
endClass
